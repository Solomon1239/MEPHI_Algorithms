# MEPHI_Algorithms

---

## GeneratePresetImpl (генерация армии)

1) Сортирую типы по `attack / cost`.  
2) Если одинаково - по `health / cost`.  
3) Дальше по каждому типу добавляю юнитов, пока:
   не будет 11 юнитов этого типа
   хватает очков
   есть место на поле (левая зона `x=0..2`, `y=0..20`)

Чтобы юниты не всегда ставились одинаково, я заранее собираю список всех клеток `0..2 x 0..20` и перемешиваю его. Перемешивание сделал детерминированным (seed из `maxPoints` и количества типов), чтобы результат не зависел от удачи, но и не был всегда одним и тем же.

По сложности:
  сортировка типов: `O(T log T)`
  добавление юнитов: максимум `11*T`, т.е. `O(U)`  
Итого: `O(T log T + U)`.

---

## SimulateBattleImpl (симуляция боя)

Бой идёт раундами. В каждом раунде:
  собираю всех живых из обеих армий
  кладу в приоритетную очередь по `baseAttack` по убыванию
  по очереди вызываю `unit.getProgram().attack()`
  после каждого хода печатаю лог через `printBattleLog`

Если юнит погиб до хода - у меня это решается проверкой `isAlive()` перед ходом. Если юнит убит раньше - он просто пропускается.

Ещё один стоп-кейс: если за целый раунд никто не нашёл цель (все атаки вернули `null`), бой заканчиваю, чтобы не зависнуть бесконечно в раундах.

Сложность на раунд:
  собрать очередь: `O(N log N)`
  пройти всех: `O(N * A)` (где `A` - стоимость `attack()`)  
Итого: `O(N log N + N*A)`.

---

## SuitableForAttackUnitsFinderImpl (цели для атаки)

Смысл метода - не гонять поиск пути ко всем подряд, а сразу отдать только тех, кого реально можно достать (не закрыты своими).

  на каждый `y` смотрю, есть ли живой юнит в колонке “ближе к атакующему”
  юнит считается доступным, если перед ним (в соседней по x колонке со стороны атакующего) нет живого юнита на том же `y`

Для `isLeftArmyTarget` просто меняется направление.

Сложность линейная: один проход по всем юнитам в трёх колонках.  
`O(K)`, где `K` - количество юнитов в этих колонках.

---

## UnitTargetPathFinderImpl (поиск пути)

Тут использую BFS по сетке 27x21, потому что шаги все одинаковые по цене (1 клетка), значит BFS и есть кратчайший путь.

  8 направлений (включая диагональ)
  все живые юниты, кроме атакующего и цели - препятствия
  если путь не найден - возвращаю пустой список

Сложность: `O(W*H)`, память тоже `O(W*H)`. На фиксированном поле это быстро.
